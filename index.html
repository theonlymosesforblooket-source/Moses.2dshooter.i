<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Zombie Arena</title>
<style>
body, html {
    margin:0;
    padding:0;
    overflow:hidden;
    background:#111;
    font-family: Courier New, monospace;
}
canvas {
    display:block;
    cursor: crosshair;
    width:100vw;
    height:100vh;
}
#ui-overlay {
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.95);
    border:3px solid #0066CC;
    padding:40px;
    text-align:center;
    color:white;
    display:none;
    z-index:10;
    box-shadow:0 0 20px #0066CC;
}
.btn {
    background:#0066CC;
    color:white;
    border:none;
    padding:15px 30px;
    margin:10px;
    cursor:pointer;
    font-size:18px;
    font-weight:bold;
    border-radius:5px;
}
.btn:hover {
    background:#0088ff;
    transform:scale(1.05);
}
h1 {
    color:#ff3333;
    margin-top:0;
}
#trait-buttons, #class-buttons {
    margin-top:20px;
}
#trait-buttons .btn, #class-buttons .btn {
    display:block;
    width:100%;
    max-width:320px;
    margin:8px auto;
}
</style>
</head>
<body>

<div id="ui-overlay">
    <h1 id="menu-title">UPGRADE MENU</h1>
    <p id="menu-text">SELECT UPGRADE:</p>
    <div id="trait-buttons">
        <button class="btn" data-trait="power">POWER (+BULLETS)</button>
        <button class="btn" data-trait="agility">AGILITY (FASTER RELOAD)</button>
        <button class="btn" data-trait="mobility">MOBILITY (MOVE SPEED)</button>
        <button class="btn" data-trait="control">CONTROL (TIGHTER SPREAD)</button>
        <button class="btn" data-trait="durability">DURABILITY (+HITS)</button>
    </div>
    <div id="class-buttons" style="display:none;">
        <button class="btn" data-class="shotgun">SHOTGUNNER</button>
        <button class="btn" data-class="sniper">SNIPER</button>
        <button class="btn" data-class="machine">MACHINE GUNNER</button>
    </div>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ui = document.getElementById('ui-overlay');

const WORLD_SIZE = 8000;
const CENTER = { x: WORLD_SIZE / 2, y: WORLD_SIZE / 2 };
const MINIMAP_SIZE = 220;
const MINIMAP_PADDING = 18;

let camX = 0, camY = 0;

let playerClass = null;
const TRAITS = {
    power: 0,
    agility: 0,
    mobility: 0,
    control: 0,
    durability: 0
};

const CLASSES = {
    shotgun: {
        name: "Shotgunner",
        bulletCount: 6,
        shootCooldown: 900,
        speed: 8,
        bulletSize: 4,
        spread: 0.35,
        maxHitsMod: 1
    },
    sniper: {
        name: "Sniper",
        bulletCount: 1,
        shootCooldown: 2000,
        speed: 9,
        bulletSize: 7,
        spread: 0.02,
        maxHitsMod: -1
    },
    machine: {
        name: "Machine Gunner",
        bulletCount: 1,
        shootCooldown: 200,
        speed: 9,
        bulletSize: 2,
        spread: 0.12,
        maxHitsMod: 0
    }
};

let player = {
    x: WORLD_SIZE / 2,
    y: WORLD_SIZE / 2,
    angle: 0,
    baseSpeed: 10,
    size: 10,
    hits: 1,
    maxHits: 1
};

let bullets = [];
let enemies = [];
let round = 1;
let zombiesKilled = 0;
let lastShotTime = 0;
let lastHitTime = 0;
const HIT_COOLDOWN = 500;

let gameActive = true;
let isClassMenu = false;
let zombieSpeedBonus = 0;

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.imageSmoothingEnabled = false;
    camX = player.x - canvas.width / 2;
    camY = player.y - canvas.height / 2;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function worldToScreen(wx, wy) {
    return {
        sx: Math.round(wx - camX),
        sy: Math.round(wy - camY)
    };
}

function clampWorld() {
    player.x = Math.max(0, Math.min(WORLD_SIZE, player.x));
    player.y = Math.max(0, Math.min(WORLD_SIZE, player.y));
    camX = Math.max(0, Math.min(WORLD_SIZE - canvas.width, player.x - canvas.width / 2));
    camY = Math.max(0, Math.min(WORLD_SIZE - canvas.height, player.y - canvas.height / 2));
}
let mouse = { x: 0, y: 0 };
let keys = {};

window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (e.code === 'Space') e.preventDefault();
});
window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
});
canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

function drawMinimap() {
    const mapSize = MINIMAP_SIZE;
    const scale = mapSize / WORLD_SIZE;
    const x = MINIMAP_PADDING;
    const y = canvas.height - mapSize - MINIMAP_PADDING;

    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "#0b0b0b";
    ctx.fillRect(x, y, mapSize, mapSize);
    ctx.strokeStyle = "#00ccff";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, mapSize, mapSize);

    const cx = x + CENTER.x * scale;
    const cy = y + CENTER.y * scale;
    ctx.fillStyle = "#333";
    ctx.fillRect(cx - 2, cy - 2, 4, 4);

    ctx.fillStyle = "rgba(255,60,60,0.9)";
    for (let e of enemies) {
        const ex = x + e.x * scale;
        const ey = y + e.y * scale;
        ctx.fillRect(ex, ey, 2, 2);
    }

    ctx.fillStyle = "lime";
    const px = x + player.x * scale;
    const py = y + player.y * scale;
    ctx.fillRect(px - 3, py - 3, 6, 6);

    ctx.restore();
}

function computeDangerLevel() {
    const dist = Math.hypot(player.x - CENTER.x, player.y - CENTER.y);
    const maxDist = WORLD_SIZE / 2;
    let danger = 1 - (dist / maxDist);
    if (danger < 0) danger = 0;
    if (danger > 1) danger = 1;
    return danger;
}

function applyTrait(trait) {
    TRAITS[trait]++;

    if (trait === 'durability') {
        player.maxHits++;
        player.hits = player.maxHits;
    }
}

function getEffectiveBulletCount() {
    let base = playerClass ? playerClass.bulletCount : 1;
    base += TRAITS.power;
    return Math.max(1, base);
}

function getEffectiveShootCooldown() {
    let base = playerClass ? playerClass.shootCooldown : 1000;
    const factor = Math.pow(0.9, TRAITS.agility);
    return Math.max(80, base * factor);
}

function getEffectiveSpeed() {
    let base = playerClass ? playerClass.speed : player.baseSpeed;
    base += TRAITS.mobility * 0.6;
    return base;
}

function getEffectiveSpread() {
    let base = playerClass ? playerClass.spread : 0.18;
    const factor = Math.pow(0.9, TRAITS.control);
    return base * factor;
}

function getEffectiveBulletSize() {
    return playerClass ? playerClass.bulletSize : 3;
}
function resetGame() {
    bullets = [];
    enemies = [];
    round = 1;
    zombiesKilled = 0;
    playerClass = null;
    TRAITS.power = 0;
    TRAITS.agility = 0;
    TRAITS.mobility = 0;
    TRAITS.control = 0;
    TRAITS.durability = 0;
    player.maxHits = 1;
    player.hits = 1;
    player.x = WORLD_SIZE / 2;
    player.y = WORLD_SIZE / 2;
    player.angle = 0;
    zombieSpeedBonus = 0;
    gameActive = true;
    isClassMenu = false;
    ui.style.display = 'none';
    spawnRound();
}

function spawnZombieAroundPlayer() {
    const radius = 600 + Math.random() * 200;
    const angle = Math.random() * Math.PI * 2;
    const danger = computeDangerLevel();
    const speed = 0.7 + (round * 0.05) + zombieSpeedBonus + danger * 0.3;

    enemies.push({
        x: player.x + Math.cos(angle) * radius,
        y: player.y + Math.sin(angle) * radius,
        size: 18,
        speed: speed
    });
}

function spawnRound() {
    enemies = [];
    const danger = computeDangerLevel();
    const baseCount = 6 + round * 1.5;
    const extra = Math.floor(danger * 12);
    const total = Math.floor(baseCount + extra);

    for (let i = 0; i < total; i++) {
        spawnZombieAroundPlayer();
    }
}

function applyZombiePermanentUpgrade() {
    zombieSpeedBonus += 0.2;
}

function openTraitMenu() {
    isClassMenu = false;
    document.getElementById('menu-title').innerText = `ROUND ${round} CLEAR`;
    document.getElementById('menu-text').innerText = 'SELECT A TRAIT UPGRADE:';
    document.getElementById('trait-buttons').style.display = 'block';
    document.getElementById('class-buttons').style.display = 'none';
    ui.style.display = 'block';
    gameActive = false;
}

function openClassMenu() {
    isClassMenu = true;
    document.getElementById('menu-title').innerText = 'CHOOSE YOUR CLASS';
    document.getElementById('menu-text').innerText = 'SELECT ONE (PERMANENT FOR THIS RUN):';
    document.getElementById('trait-buttons').style.display = 'none';
    document.getElementById('class-buttons').style.display = 'block';
    ui.style.display = 'block';
    gameActive = false;
}
function shoot() {
    const now = Date.now();
    const cooldown = getEffectiveShootCooldown();
    if (now - lastShotTime < cooldown) return;
    lastShotTime = now;

    const bulletCount = getEffectiveBulletCount();
    const spread = getEffectiveSpread();
    const bulletSize = getEffectiveBulletSize();
    const speed = 22;

    const baseAngle = Math.atan2(
        (mouse.y + camY) - player.y,
        (mouse.x + camX) - player.x
    );

    const half = (bulletCount - 1) / 2;

    for (let i = 0; i < bulletCount; i++) {
        let angle = baseAngle;
        if (bulletCount > 1) {
            angle = baseAngle + ((i - half) / half) * (spread / 2);
        }

        bullets.push({
            x: player.x,
            y: player.y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            size: bulletSize
        });
    }
}

function update() {
    if (!gameActive) return;

    const now = Date.now();

    let vx = 0, vy = 0;
    if (keys['w']) vy -= 1;
    if (keys['s']) vy += 1;
    if (keys['a']) vx -= 1;
    if (keys['d']) vx += 1;

    const mag = Math.hypot(vx, vy) || 1;
    const speed = getEffectiveSpeed();
    vx = (vx / mag) * speed;
    vy = (vy / mag) * speed;

    player.x += vx;
    player.y += vy;
    clampWorld();

    if (vx || vy) {
        player.angle = Math.atan2(vy, vx);
    }

    if (keys[' ']) shoot();

    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.dx;
        b.y += b.dy;

        if (b.x < 0 || b.x > WORLD_SIZE || b.y < 0 || b.y > WORLD_SIZE) {
            bullets.splice(i, 1);
            continue;
        }

        for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (Math.hypot(b.x - e.x, b.y - e.y) < (e.size / 2 + b.size)) {
                enemies.splice(j, 1);
                bullets.splice(i, 1);
                zombiesKilled++;
                break;
            }
        }
    }
    // zombie movement
    for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx, dy) || 1;
        const mx = (dx / dist) * e.speed;
        const my = (dy / dist) * e.speed;

        e.x += mx;
        e.y += my;
    }

    // zombie-zombie collision
    for (let i = 0; i < enemies.length; i++) {
        for (let j = i + 1; j < enemies.length; j++) {
            const a = enemies[i];
            const b = enemies[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy);
            const minDist = (a.size / 2) + (b.size / 2);

            if (dist > 0 && dist < minDist) {
                const overlap = minDist - dist;
                const pushX = (dx / dist) * (overlap / 2);
                const pushY = (dy / dist) * (overlap / 2);
                a.x -= pushX;
                a.y -= pushY;
                b.x += pushX;
                b.y += pushY;
            }
        }
    }

    // reflection-style hits
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (Math.hypot(player.x - e.x, player.y - e.y) < (e.size / 2 + player.size)) {
            if (now - lastHitTime > HIT_COOLDOWN) {
                enemies.splice(i, 1);
                player.hits -= 1;
                lastHitTime = now;
                if (player.hits <= 0) {
                    resetGame();
                    return;
                }
            }
        }
    }

    // round clear
    if (enemies.length === 0) {
        if (round % 5 === 0 && round > 0) {
            applyZombiePermanentUpgrade();
        }

        if (round === 10 && !playerClass) {
            openClassMenu();
            return;
        }

        if (round < 10) {
            openTraitMenu();
        } else {
            round++;
            spawnRound();
        }
    }
}
function drawPlayer() {
    const p = worldToScreen(player.x, player.y);
    ctx.save();
    ctx.translate(p.sx, p.sy);
    ctx.rotate(player.angle);
    ctx.fillStyle = "#00ccff";
    ctx.beginPath();
    ctx.moveTo(player.size, 0);
    ctx.lineTo(-player.size, -player.size / 1.5);
    ctx.lineTo(-player.size, player.size / 1.5);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // hits indicator
    for (let i = 0; i < player.maxHits; i++) {
        ctx.fillStyle = i < player.hits ? "lime" : "#550000";
        ctx.fillRect(20 + i * 24, 20, 20, 20);
    }
}

function drawEnemies() {
    ctx.fillStyle = "#ff4444";
    for (let e of enemies) {
        const p = worldToScreen(e.x, e.y);
        ctx.beginPath();
        ctx.arc(p.sx, p.sy, e.size / 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawBullets() {
    ctx.fillStyle = "#ffff66";
    for (let b of bullets) {
        const p = worldToScreen(b.x, b.y);
        ctx.beginPath();
        ctx.arc(p.sx, p.sy, b.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawWorldBounds() {
    const tl = worldToScreen(0, 0);
    const br = worldToScreen(WORLD_SIZE, WORLD_SIZE);
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 4;
    ctx.strokeRect(tl.sx, tl.sy, br.sx - tl.sx, br.sy - tl.sy);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawWorldBounds();
    drawBullets();
    drawEnemies();
    drawPlayer();
    drawMinimap();
}

document.getElementById('trait-buttons').addEventListener('click', e => {
    if (!e.target.classList.contains('btn')) return;
    const trait = e.target.getAttribute('data-trait');
    applyTrait(trait);
    ui.style.display = 'none';
    gameActive = true;
    round++;
    spawnRound();
});

document.getElementById('class-buttons').addEventListener('click', e => {
    if (!e.target.classList.contains('btn')) return;
    const cls = e.target.getAttribute('data-class');
    playerClass = CLASSES[cls];

    player.maxHits = 1 + TRAITS.durability + (playerClass.maxHitsMod || 0);
    if (player.maxHits < 1) player.maxHits = 1;
    player.hits = player.maxHits;

    ui.style.display = 'none';
    gameActive = true;
    round++;
    spawnRound();
});

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

resetGame();
gameLoop();
</script>
</body>
</html>
